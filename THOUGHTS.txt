
    TODO REMOVE FROM GIT IF WE MAKE THE CODE PUBLIC


    BUG LIST
        1) Grid Transform autoparent adjust thingy is buggy; transforming, interpreting, transforming, then interpreting again yields bad results.
            adjusting params of gT triggering a re-inherit MIGHT fix problem; or might exacerbate. Needs thinking. As stands, works, but fragile.
        2) We still don't have a satisfactory answer for that Jan 11 "Mystery Stochastic Segfault".
        3) TI-landing doesn't work because of the sheather. What to do?
            --> Here's your answer: make a "Landing TI" and wherever it's used the parcel leading into it is given gatesize at least 2
                (we'll have to square it with the sheather though; the sheathing must be removed anyway)

    FEATURE / IMPROVEMENT LIST
        1) Flip option for mapHelper autotile
        2) "waterworld" grid recursor kitbash
        3) Some sort of error handler (mostly to deal with malformed signatures (or we could sidestep them with a later "signature validity checker"))
        4) Add "expansion direction" back in, for picking where to add lengthening parcels?
        5) Add isolation floodfill to the DFS maze generator
        6) Ledgeblock improvements (see notepad)
        7) Walkway complexification (core superwidth leftsider and shield appender) (needs incidental goof handle...)
        8) Postprocess: Rock sprinkler
        9) Postprocess: Countersinker
        10) Longfail recursor type: failing a puzzle causes retraversal of large area
        11) Make parcel selector data-driven; the parcel selector as a whole doesn't need to know what it's selecting at all.   
        12) Experiment with height-based base selection schemes ("tidal grotto")
        13) If ledge units are too long, widen their blockage shield (so that we can hand it off to a ridgebreaker or at least the oozer; end those "fences"!)


    WILD FUTURE OPTIMIZATION LIST
        1) Replace heap-resident parcel data struct pointer with data struct union (of all possible data structs, they're small)?
        2) Is recomputing the min dim data for the grid recursor actually cheaper than storing it?
        3) Signature copying to heap is probably obscenely expensive; find a way around it
            -> Change grid signatures from SoA to AoS
        4) "Alias Method" for weighted prob dist recursor pattern select


    THOUGHTS ABOUT THE POSTPROCESSOR:
        1) See v1 and v2.
        2) Develop replacement automaton (a la KMP)
        3) Jan 8 idea: Just as UNRESOLVEDS can be filled with blockage as long as they don't obstruct, so too can BLOCKAGES be filled with blank floors as long as
            they still obstruct. The same logic can be used for BOTH CIRCUMSTANCES. Chew on that later.
        4) Jan 8 scrapped the edgetracer in favor of a void-appender device.
            NOTE: the global params should include whether this is permitted -- after all, the algorithm could be invoked to generate a small part of a larger cave
                    Think on't.
            An edgetracer of sorts may still be necessary for the doorways to work...?
            OR THE DOORS ARE PART OF THE ALGO, REALIZED AS E-PARCELS!!!
        5) Think about an L-sys Blockage increaser pass (i.e. an UNRESOLVED surrounded on three sides by BLOCKAGE becomes itself BLOCKAGE, enqueues neighbors, etc.)

    ASSUMPTIONS TO ADD TO THE DOCS:
        0) The whole T-shape entry kerfuffle of Jan 21 needs a mention (in terms of "entering" a parcel)
        1) Parcels always possess a tile on either side of their gate that doesn't contain the gate, to avoid the corner-clash sheath problem.
        2) All gates are present in the parcel (assumption from sheather). If a parcel doesn't use a gate it sets its size to zero.
        3) As it stands there's probably an implicit upper limit on gate width ("4" or something, and that would lead to weirdness)
            --> adjust resizers accordingly??
            Gate sizes should remain between 0 and 3 -- I don't really think about the ramifications of gates larger than that and some base generators
            may yield odd/incorrect behaviour.


=== Through Jan 20 moved to OLDTHOUGHTS.txt ===

===============================================================================
    January 21: Back on the whole parameter thingy

    Thought up an inelegant solution to the grid recursor param clash.
    The Recursor is given a param array as a third parameter.
    In selector calls, this is always null, and is an instruction to the recursor to divide its own parameter among its children using the grid signature as a guide.
    In a supercall, it is a list of parameters, which the recursor assigns to each child serially, ignoring its own parameter and not performing division.
    There are a couple of hitches that need a bit more thought:
        1) Void bubbles need no parameters, and are present often in the initial signature. How do we describe in array? Ignored Filler struct?
        2) Before we were reasoning about PATHs as opposed to individual parcels. Would it be better to provide PATH PARAMETERS and still perform some division
            automatically?
            (probably overblown; initial grid sigs are by nature small...? But we're doing it for subunits...? It's ONLY for forks. It's an OVERENGINEERED FEATURE.)
        3) How can we streamline parameter input representation the most?
    WE NEED TO REMOVE THE IDEA OF PATHS. IT'S OVERENGINEERED.
    The paths only mean something in the case of FORK RECURSORS. In Flange recursors, they don't mean enough.
    We *could* just pretend that flange recursors don't exist.
    Also, Fork recursors only branch out to two -- any more and we get there by a second recursion step. The second branch of a fork is also pretty much invariably
    a shortcut. We could make that a true assumption.
    SO -- instead of ""Paths"" we now have a single flag as part of the signature: whether the parcel is a shortcut or not.
    This is allowed by the assumption that THERE CAN ONLY EVER BE ONE SHORTCUT PARCEL IN A FORK.
    This is TRUE. Forks can only meaningfully exist in L- or I-cases; in either case, there's only one shortcut parcel (inner L or top/bottom I).

    Another consideration about the nature of parameters themselves that we haven't considered is RELATIVE FREQUENCY OF FEATURE. As it stands, the generator is
    not given HOW OFTEN an optional type should appear; only that it can/can't appear. 
    PERHAPS THINKING ABOUT REL-FREQ is OVERENGINEERING.
    After all, in our source material, precious few caves have more than two optional base cases.
    The selector can reason about recursors on its own.
    This way we can use bitmasks to identify optional content.
    Which clashes with the use of a list for the mandatory content. *sigh* It's such a damn good idea though!

    We're going to take a break and work on some more base cases.
    Just discovered the juicy idea of Ledge T-shapes, where the ledge places in the flange part. Is this the *only* case in which a ledge need appear....?
    (No; higher order thinking may allow "ledge cycles" and other i-case stuff)
    Even better: is this the only case for a T-shape that's not base-case?
    
    WHOA: MAJOR MAJOR OVERSIGHT. UNBELIEVABLY HUGE MISTAKE. If the recursor grid topology loops, then some branches of T- or X- parcels MUST BE ENTRANCES.
    AND AN ENTRANCE MEANS GAZUMPTION.
    We can paper this over with a couple of assumptions and a kludge, but it's still a whopping great hole in our thinking.
    The way it currently stands, there are TWO THINGS that have branches as entrances: Bridges and Ledges.
    Of those two, Ledges are the only ones that can be reasonably modelled as parcels (and the kludge below ought to work for bridges too, if we choose "bad modelling")
    If we assume:
        a) In T-shaped ledges, the ledge construct is always placed entering from the branch
        b) The height of a ledge parcel is always zero
    Then:
        a) The ledge will have no sheath, and therefore no weird gate
        b) A parcelwide landing strip contacts the gate from the adjacent parcel, and on its other side, the ledge runs all the way along. Looks fine, doesn't trigger
            the CA problem from before.
        c) We can then chain ledges together until we touch the I/L shaped main path.
    BRIEF GRAPHING SHOWS TI-LEDGE NONFUNCTIONAL due to collision with the main walkway.
    THIS IS TERRIBLE.

    We can't let this kill the project. Brainstorm a solution.
        1) Swap idea for ledge from T-entrance to L-exit; make so the only T-parcel is a topologically contiguous lump of floor (that way, walkway collisions don't matter)
        2) Only use ledges on the edges of recursors, then clobber the T-gate so it doesn't touch (we can totally do that!); use the recursor's walkway instead.
    NOTE: due to the CA optimization, the WALKWAY DRAWING UNIT needs a notion of whether there's a landing strip coming in from below/above.
    There are TWO USE CASES for ledge loops:
        1) Autogenous arising to add a short way from exit to entrance (Uses a TL Entry ledge for I-case, and an L Ledge with 2 TI blanks for L-case)
        2) Goof-based (either mandatory or incidental) backloop, where L-case is fine (Uses a TL entry ledge and a TL blank, and places the goof in a goof L)
            but I-case necessitates the Goof and the Ledge being placed in the same unit (Assuming a single parcel for the puzzle).
            Here's the thing: That's a good idea. The puzzle will take up a fair bit of space, so adding the ledge to the goof unit means the goof unit can fill the
            space itself, using the ledge.
    So we actually need:
        1) TL Entry ledge
        2) L Ledge with or without goof on the entry side
        3) Blank TL exits/entries (Base case with a modification to the walkway drawing logic such that the lowest strip is all TILE_BLANK)
        WALKWAY CAN DETECT THE NEED FOR THIS SANS FLAGS; it just checks to see if the core tile adjacent to the bottom right of itself is TILE_BLANK. 

    Hm. There's also a ramification for the metric divider here. If the selector decides to make a ledge loop in case of mandatory goof (does this actually happen?)
        Then the goof is always placed by the ledge, and the puzzle next to it.
   

    Wrote the ledge base case; seems to work (haven't tested it in a recursor yet -- MS 4 and 5 giving me trouble)
    NEXT STEP: add WALKWAY TI DETECTOR.
    There's a wrinkle: the sheather. The sheather is still sheathing the parcel in topo-unadj (as behooves it, it's the L-fix)

    Also by the by, void doesn't tile. The "crinkly border" effect (HGSS) comes from extra geometry on cliff tiles reaching into the void, or something like that. 

===============================================================================
    January 22
        
    Shelve Ledge TI thing for now (see bugs up top for possible fix)
    For bridges, use a recursor where the bridge is a blank I-parcel, then have the parcel on one side of it gazump from parcel on far side, then draw bridge
    between said gates (stair replace). Recursor's height sels will be fixed, for easy case analysis/debug.

    Also thought: to save on reworking ledge recursor, if ledge has goof, it's placed in the ledge block.


===============================================================================
    January 24

    For the parameter thing to go ahead, perhaps it's time we tackled it from the other end. Up till now the selector has been a black box. Let's elucidate the
    selection algorithm.

    Here's an outline:
        1) If we're over maximum fractal depth, attempt to bottom out. (invert param -- bottom out at zero?) (two params tracking in both directions?)
        2) Decide whether to RECURSE or BOTTOM OUT.
        ATTEMPT TO BOTTOM OUT is as follows:
            1) If we have more than one obligate, recurse again and repeat.                 (lengthening)
            2) If we have exactly one obligate, become the base case associated therewith.  (satisfaction)
            3) If we have no obligates:
                4) If we have no potentials, become the base case fallback.                 (failsafe)
                5) Otherwise, select a potential and become the associated base case.       (selection)
    
    The key step is the "decision of whether to recurse". This isn't binary; it's a decision of what to recurse TO.
    Our recursive patterns generalize to the following classes:
        - Void incursions               (a V-SHAPE appears somewhere in the grid)
        - Lengtheners                   (multiple gridcells but no special ones)
        - Shortening Ledge Loops        (ledge provided to loop back to parcel entry)
        - Puzzle Ledge Loops            (pass through puzzle, get goof, return to entry) --> NOTE: due to nature of T-shapes, this is ACTUALLY A "BASE CASE".
        - Flanges                       (branching path capped by E-shape with goof) (See below: or without goof, if it's a fakeout)
        - Bridge Loops                  (path loops under/over itself using a bridge unit)
        - Forks                         (path bifurcates)

    In terms of what each shape can do with OBLIGATES:
        - Void incursions don't do anything (sometimes they don't even lengthen the path)
        - Lengtheners and Bridge Loops distribute obligates evenly (in guaranteed order) among their member parcels
            --> Note: this means we can't use the old algo (even dist.)
        - Shortening Ledge Loops could, in theory, absorb obligate goof into their ledge (real dick move though)

        - Puzzle ledge loops, Flanges, and Fork Shortcuts all use FLANGE LOGIC; i.e. they add post-factum goof.
        Which raises an interesting point. Up till now we've been assuming that post-factum goof is just something the engine decides on automatically;
        that is, it makes a challenge/reward pair out of thin air.
        But think: you're in Victory Road. You jump a trivial Bike Puzzle -- one you've jumped before in the early game -- and are rewarded with a Repel.
        Insulting game design, you think. So the reward/puzzle pair must be tied to some sort of global challenge rating -- and that's the sort of specious
        undefined shit that breaks our beautiful algorithm.

    So we come to a point of order: THE ASCOSPEL RECURSOR ALGORITHM SHOULD NOT CONCERN ITSELF ABOUT THE DIFFICULTY OF A CHALLENGE, OR THE VALUE OF A REWARD.
    It's a CONTENT PLACEMENT SYSTEM, not a CONTENT GENERATOR. This is a theoretical distinction of great importance.
    When the puzzles are generated, they use parameters that the algorithm doesn't touch.
    Goof is drawn from external tables, not from the recursive structure.

        There's one last point to address, to complete our understanding. Puzzle ledge loops and Flanges are divided into two classes:
        Backtracking and Non-Backtracking.
            "Backtracking" means the player has to return to the cave to breach the puzzle, using some later power. The goof should be commensurate.
            "Non-Backtracking" means the player could complete the puzzles as they are, they merely have to decide to deviate from the path.
        There is no difference structurally between the two.
    IN FACT, this brings up an interesting point about forks -- they're always fork-shortcuts, and always of the backtracking type -- otherwise the player
    could just take the shortcut to avoid the obligatory content, and having obligatory content in duplicate could lead to some really silly results.
        The nature of backtracking leads to a concern: Multiple backtracking. If the player can return to a cave multiple times with new powers in hand, it
        would be silly for the incidental goof to be all of one level.
        Also note that multiple backtracking is handled automatically by a superinovker context, by using the OBLIGATE locks on a flange in the grid pattern.
    In short, it may behoove us to allow only one kind of backtrack lock per parcel.
    Non-backtracking flanges and puzzle loops draw from the potential pool.

    
    The choice as to which recursive pattern to use is based on two things:
        1) Whether the pattern is explicitly permitted (enforce that some patterns always are, to allow for lengthening assumptions).
        2) The depth of recursion. We'd expect usage as follows:
            - Void incursions: High and Mid level, where the void can be large and pan out.
            - Lengtheners: Lowest level. Lengtheners are primarily used if the obligates aren't all distributed, but could have some random insertions to
                keep the map from being boringly minimal.
            - Shortening Ledge Loops: High level, to allow fast return-to-entrance; also a Mid-level lengthener.
            - Puzzle Ledge Loops: These are actually a sort of base case, because the only variable parcels are the goof and the puzzle (which must be known anyway)
            - Flanges: Hard to say. From the perspective of the critpath these are basically lengtheners, and should maybe be used in the same fashion.
                After all, incidental flanges are identical to Puzzle ledge loops, only with no ledge. Perhaps that's the thing -- they're used wherever lengthening would
                be advantageous.
            - Bridge Loops: Mid-level. Passing over the initial path is powerful -- you can see where you were and where you're going.
            - Forks: High and Low level -- offer both fast-travel-forward and incidental passage.
        3) Just detected this one; it's WHETHER TO LENGTHEN. Obviously if we bottom-out with multiple obligates it's forced, but the decision of whether to lengthen
            is interesting. It's a content generation decision that only the asospel recursor can make (violating our above assertions).
            Roughly put:
                - If we have more than one obligatory, we're likelier to lengthen (even if we weren't going to bottom out)
                - If we have one or fewer obligatories, we're asking the question: Is the cave long enough?
            So we could add a parameter: path length.
            Every time we recurse, we subtract the number of non-obligatory parcels in our grid from this parameter, then divide the remainder at random among
            our children. If a parcel has zero path length, it attempts to bottom out; otherwise it recurses.
            The values subtracted are only parcels on the critical path.
        This way we can ask for a cave that has "Two NPCs, one Prefab, and 10 bits of other stuff"

    There are other tuning concerns also. Sometimes we want a very direct cave (No flanges, no puzzle ledge loops). Sometimes we want a sprawling nonsense mess.
    Sometimes we even want heaps of fakeouts (think Iron Island; lots of flanges with nothing at all at their ends).

    Here's a thought: Since the number of recursors is fixed and quite small, we could have GLOBAL LIKELIHOODS (or even local likelihoods) for each.
    Combine that with their likelihoods as a result of depth and we've got ourselves an OK decider function.
    We could even conceive of a per-level probability table (global): e.g. 
        Level 0: 100% Fork, 0% anything else; 
        Level 1: 10% Fork, 30% Flange, 20% LedgeLoop;
        Level 2: 30% LedgeLoop, 30% Flange, 5% bottom out;
        Level 3: 40% PuzzleLoop, 50% bottom out;
        Level 4: 100% bottom out
    Such a table could be static, modulated by the permissions set, or could define in the abstract a "type" of cave.
    PROTOTYPE INDEPENDENTLY.
    Prototype is favourable.
    And hey! This allows for us to prescribe MANDATORY RECURSORS, as well (to a point, of course)...!
    Place details in their own file; abstract away functionality as much as possible (call it typeSelector or something)


    Next question:
        We've decided on a recursor type in selection, but there are still subparameters needing decision.
            - Void Incursions:          Where do we put the void bubble relative to the path?
                --> Make this a "standard" instead, and mirror I-units in recursors when building them
            - Lengtheners               In what direction do we lengthen?
            - Puzzle Ledge Loops        What reward do we place?
            - Fakeout Flanges           Do we place anything at the end? Where does the branch fall relative to the path/how long is it?
            - Reward Flanges            What reward do we place? What challenges await on the branch? Where does the branch fall relative to the path/how long is it?
            - Forks                     Which shortcut method do we use if more than one is available? (assuming we don't go with simplifying assumption that there's
                                        only one backtracking lock)

    We still haven't resolved incidental reward theory. Shelve it for now; it has no effect on WHETHER the reward is placed.

    Implementation note: put base prob at beginning to allow for PROBABILITY TABLE EXTENSION as we add future recursor types.


===============================================================================
    January 25: Implementing the Recursive pattern selector

    Initial thought about parameter division: Parameter division ought now to be handled by the selector itself; there's just enough fluff in the system that we don't
    need to get the irritating grid signature involved. This also solves our headaches about the initial condition parameter division.

    The hurdle is then this: It's the grid recursor that allocates the memory in which the parameters are stored. This is what gets in our way.
    Our kludge was to pass an optional clobbering param array, which would be copied.
    The situations in which we need the selector to control parameters are:
        1) Initial invocation (arbitrary grid pattern)
        2) Puzzle Ledge Loops (selector needs control over the puzzle and the goof)
        3) Reward Flanges (selector needs control over the goof)
    Ultimately here's the thing: We're getting rid of the "paths" idea (only one use case), and the division of parameters is ultimately NOT THE RESPONSIBILITY OF
    THE GRID RECURSOR.
    The parameters are preset by the invoking context, or their division depends on the nature of the recursive pattern -- a nature which is described to, not decided by,
    the grid recursor.

    THEREFORE WE PROPOSE A RADICAL KLUDGE:
    The child parcel array is preallocated by the selector for the grid ideator (but still freed by the grid realizer) and prepopulated with parameters.
    This is a dangerous slippery slope vis-a-vis signatures; after all, if we're presetting children and their parameters, why not preset their shapes as well?
    Why not run their ideators for them? Why bother with a grid signature at all?

    ALTERNATIVE SOLUTION:
    Rework the idea of "paths" in the signature. Each parcel in a recursor has a "type" which defines which of the parameters it gets!
    Parcels can be:
        VOID: no meaningful parameters, as it will always bottom out to a void-bubble
        STRUCTURAL LEDGE: no meaningful parameters, as it will always bottom out to a goofless ledge
        BRIDGE: no meaningful parameters, but does have a bizarre effect on gazumption (later device)

        CRITICAL PATH: There is exactly one critical path in the parcel, among which the obligate parameters are divided serially, in order, as agreed.
        CRITICAL BRANCHOFF: A t-junction on the critical path. Jury's out on whether T-shapes can recurse at all -- could just base-case out...?
            --> There are no "critical branchbacks"; these cases are always handled by TL-ledges due to double-walkway error in reasoning
        SHORTCUT PATH: Gets the backtracking lock parameter set. Assume only ever one per parcel.

        FLANGE PUZZLE: Gets a goof-protecting puzzle (either backtracking or immediate; is there a structural difference?)
        FLANGE REWARD: Gets reward goof (is probably a goofy ledge or a flange terminus)


    VOID, STRUCTURAL LEDGE, CRITICAL BRANCHOFF (assuming it bases out), and BRIDGE are all of a kind: a parcel that doesn't need parameter path division, only
    basics like gate width.

    CRITICAL PATH is the only parcel requiring serial division among multiple members of its kind.

    SHORTCUT PATH requires no division: a shortcut path is always given the backtracking lock as an obligate component.
        As to what it's given for goof, etc. we don't have to worry about that yet.

    FLANGE PUZZLES and FLANGE REWARDS are always generated in sets: one or more FLANGE PUZZLES protecting a single FLANGE REWARD; where the FLANGE PUZZLES are serially
        arranged.

    Perhaps there's ONE EXTRA TYPE that means "look in the parameter list to find my parameters"; PRESET, or some such name.



    These types refer to How the Grid Recursor divides parameters, and so we'll call them "Parameter Division Types" and lump them into the grid signature in place of
    the old path data. There are 5 types:
        CRITICAL PATH   -- Divide critical path params (obligates, etc.) serially among all parcels of this type
        SHORTCUT PATH   -- Set backtracking lock to obligate for this parcel
        FLANGE PUZZLE   -- TODO
        FLANGE REWARD   -- TODO
        PRESET          -- See input list for parameters to copy
        TERMINAL        -- Parameters mostly irrelevant; this is a known base case.
   

    This seems OK. Moving ahead, here are the concrete implementation steps:
        1) Independent recursor type selector  (Done)
        2) Handcode grid signatures for each pattern
        3) Obligate list system
        4) Parameter divider thereupon based

    CAME ACROSS ANOTHER REALLY STUPID OVERSIGHT when making the handcoded grid sigs.
    There are TWO KINDS OF TL FLANGE: one where the flange continues straight, and one where it heads left. (The same is not true of TI, as we can just flip it)
    Also note the following: Ledge inputs only work for one of those kinds of flange.
    Added it in.


    HOLD ON: Is there any impediment to making the ENTIRE SELECTOR SYSTEM DATA-DRIVEN...?
    Or would such a thing be premature optimization?
    After all, the selector is a system that takes a parcel and populates it. It does so either using a GRID RECURSOR (data-based by signature) or a BASE CASE
    (data-based by function pointer); making its choice which to use based on a table (data!) in the recursive case or an obligate/random set (data!) in the base case.
    DOES THE SELECTOR, AT ANY POINT, NEED TO KNOW WHAT IT'S SELECTING OVER....?
        --> The selector does have to know what it means to "bottom out".
        --> The selector decides between grid signatures based on shape (at present).
        --> The selector has to select between potentials if no obligates (but does it need to know the mapping between potential/obligate IDs and the underlying functions?)
            (our assumption is that, for obligates, it's passing metadata to the funcs (so an NPC placer, for instance, knows which NPC it's placing))
            (but of course such context could be abstracted away)
    It's a worthy goal I think.
    ADDED TO POST-FEATURE LIST; FOR NOW IT'S NOT REALLY WORTH IT.

===============================================================================
    January 26

    Had a thought: Special fork handling in recursors may not be necessary; we MAY BE ABLE TO CREATE FORKS OUT OF WHOLE CLOTH USING NOTHING BUT T-FLANGES...?

===============================================================================

    January 27

    Observation: Are Waterworld recursors left to chance (automatic height-set/connection of water regions) or mandated by pattern?
    The latter is an argument for data-driven recursor selection.

    We've gone as far as we can go without implementing the Obligate List.
    For a while we toyed with the idea of making it a "linked list" structure; such is foolish pointlessness.
    Eat the mallocation of true array lists.

    The gist of mem management boils down to:
        1) Allocation performed by initial condition and divider
        2) Deallocation performed by divider
    Problems therewith:
        1) Initial condition ought to manage its own memory (and be able to pass stack-resident obligate lists)
        2) If the generator bases out with a nonblank obligate list, the memory is leaked (not really a problem...)
    Notes:
        1) No need for dynamically resizing array lists -- the size of each array is known at division-time.
        2) Does that mean the list could actually be stack-resident within the selector structure...?
            No. When we hand the parameters off to the divider, the divider returns before recursion occurs. Stackframe lost.

    Nature of Obligate List:
        Elements describe:
            1) Type of obligate (data-drive; refer this to a func? --> Param concern)
                PARAM CONCERN: NPC/Item/Exit ideators get hooks into the world struct through the context, but they have other parameters during ideation
                    (NPC ref, Item ref, Exit warp ref, etc.)
                But not all obligates share this need: locks, for instance, don't care about refs (though maybe they should...? after all, they change state
                BUT NOT PERSISTENTLY like Items or NPCs do)
                Therefore an obligate can either
                    a) perform a lookup in the selector, optionally passing the parameter
                OR
                    b) refer to a parcel ideator and have ALL IDEATORS POSSESS AN OPTIONAL ARGUMENT.
                Come to think of it maybe that's how it should be anyway -- such a thing makes the Grid Ideator share the same signature as other ideators.
    DIMWIT. IDIOT. NUMPTY. I performed a whole-cloth GIT RESET because of this daft idea.

    WE ALREADY HAVE THE PARAMETER STRUCTURE, THROUGH WHICH ALL THIS DATA IS ALREADY PASSED.
    If we hit a terminal symbol like an NPC encounter (which needs additional data), the data is to be found IN THE OBLIGATE LIST IN THE DAMN PARAMETER FIELD.
    UNTRANSFORMED, UNCAST, UNPASSED...!
    So all any base case has to do is look at its obligate list, and yell if there's no data there.

    ALSO REALIZED: Parameter deallocation can happen when Parcel Deallocation does: done by whatever is "child-memory-managing" (i.e. the grid recursor)
        This means the initial cond. can be static.



    ANOTHER BLOODY OVERSIGHT (this one's not so bad). Added to notes above. The parameter divider has no way of knowing which order the critpaths come in
    (without scanning) so it can't guarantee that the obligates are in order.
    SCANNING WON'T WORK EASILY. We'll need to hardcode it in the signature...!
    Idea: overclock the type somehow (e.g. CRITICAL_PATH is the last in the enum and anything greater is the next leg of the path...?)
    -> Use NEGATIVES. -1 is the first critical path, -2 the next, etc.



    Done so. So far, seems to work OK.
    Next we really have to tackle the postprocessor, with those wide-ass door edges. Needs a more general fill step than thinfilling....
    Also on the table is the height-selector. One idea is that entrances tend to be height zero (height sameness shouldn't engulf the entire grid...)


===============================================================================
    January 28

    Started by quickly implementing an isolation-based culler. Seems to work really well. Considering completely removing the thinfilling step.

    Moved height selector into its own function -- selecting heights at random, we're encountering the weirdness we predicted in v2.
    Either:
        a) Work out what states cause it and explicitly disallow
            It occurs when a recursor marking its internal parcel as -1 (bordering it) borders another parcel marked as -1 (but the recursor itself is marked 0, so
            the two don't merge).
        b) resolve using another MS-postproc

    Implemented basic large rock accretor, no problems.
    ANOTHER IDEA FOR POSTPROC: Instead of reabsorption to deal with those long blockage "fences", simply detect their presence and scrub to TILE_UNRESOLVED.
    Check this logic: if a blockage is bounded on three sides by impassable tiles, then it may safely resolve to passable floor.
    From a purely Eulerian POV, this seems sound -- after all, if it is bounded on three sides, then it doesn't matter whether it's passable or not.
    ACTUAL CHECK shows this algo only removes every other blockage from the fence (*sigh*)
    We may be able to do it with the REVERSED MOORE NEIGHBORHOOD LOCALITY CHECK. Prototype this.
    Afer all, if a blockage

===============================================================================
    January 30

    Prototyped an NPC; it's time to think about hooks perhaps. Or not.
    It may behoove us to set the static NPCs' sightlines in the generator -- these ones (placed in base-cases) can see as far as the exit gate.

    What we definitely have to do is handle the blockage-fences somehow. We can reintroduce thinfilling I think...
    AUTOMATON THAT PASSES OVER ALL BLOCKAGES.

    Had another thought about the probability for the sprinkler pass: it's affected by UNRESOLVEDs as well as impassable tiles. (i.e. an UNRESOLVED bordered
    by BLANKS has less chance to be rock-sprinkled than an UNRESOLVED bordered by other UNRESOLVEDs)

    Note: WE DON'T HAVE TO WORRY ABOUT ROCK SPRINKLER PERMISSIONS ANY MORE. Those were a relic from the WFC days, where the cave was more loosely managed.
    Now all goof is enforced by control systems; regions of the cave can be snipped off, filled, and oozed.

    Question is: Do we sprinkle before oozing, or after?
    What we could do is use the ridgebreaking step: Ridges re-resolve to blockage, fences are bashed, and we sprinkle then run general blockage resolution.
    Hm. One of the advantages of ridgebreaking was the inverse automaton.

    Note this: blockage "fences" appear in three places.
    1) The ledge parcel (where we can clobber them with ridges and ridgebreak if we have to)
    2) On the upper edge of oozed cliffs (where an inverse ooze may serve)
    3) Between same-height parcels (we really, really need to update the height-control logic...)


===============================================================================
    January 31

    Started prototyping the rock sprinkler. Here's the thinking: it activates after the oozing, and the blockages are resolved by some other component.
    ROCK SPRINKLER then
    FENCEBREAKER then
    BLOCKAGE AMALGAMATOR

    Prototype rock sprinkler shows our error: the rock expansion can cut off whole regions without triggering thinfilling.
    We need to bring back the placer-checker and screen it properly.

    Merely inverting the validRockSite checker isn't enough. We need proper inverse connectivity logic for fencebreaking.

    Prototype of this logic is correct in nature, but its function is undesired (allows bypassing of NPCs by trimming topo-adj fences). Hm. It does remove
    an AWFUL LOT of the blockages, though. Makes the ledges look a bit weird.

===============================================================================
    February 1

    The neighbor-based trimmer fell through, so we need a revision. The blockages we can safely prune are all of a kind: sitting at the tops of straight cliffs.
    A tile is a member of a "fence" if:
        1) two opposite neighbors are blockages
        2) perpendicular neighbor is cliff
        3) neighbor opposite that is flat floor (blank or unres)
    Test a looser logic: exactly three blocked neighbors, one of which is a cliff.

    THAT WORKS. Combined with thinfilling it's a good look.
    We still have the occasional problem of large topo-unadj blockers leaving unsightly 1x wide strips of blockage though.
    
    CONSIDER THIS REFINEMENT: at higher recursion levels, topo-adj blockers get wider...?
    Also, at higher levels, paths should be wider.

    Also it may be a neat idea to sprinkle once, ooze briefly, then sprinkle again -- save on blockage amalgamation...?


    THOUGHT OF A POTENTIAL SOLUTION FOR THE 1-WIDE TOPO STRIPS: MOVE THE L-PROBLEM TO THE WALKWAY DRAWING UNIT.
    Think of it this way:
        The reason we have the 1-wide gate buffer zone is to join two regions of different sheath types (i.e. different heights)
        However, this assumption exists to counter exactly one edge case: the landing zone is inside a sheath offset by one, whereas the incoming gate is not.
        This circumstance implies, definitionally, that there is already a sheath buffer between the landing parcel and its outlet parcel (a cliff).
        Therefore, there is no L-collision in that case.
    THEREFORE:
        If a parcel is not the same height as its bottom neighbor and parcel is L-shaped, the height-change blocks L-clash.
        If it is the same height, then the L-clash can be prevented by drawing a strip in the bottom of the walkway. This strip won't clobber the
        incoming gate from the left neighbor, because it must be level with it under the assumption of the gate-buffer.
    GRAPHING THIS OUT HAS SHOWN US ONE EXCEPTION.
        If the lower border is same-height sheath (blank but not culled) and the left neighbor has a culled lower border, then the gate may intersect with the
        walkway's bottom tile.
    Here's the algorithm, then, performed in the grid recursor:
        IDEATION STEP:
        1) Compute sheath data with permissive topo-adj (no L detection).
        REALIZATION STEP:
        1) If I am an L-case and my sheath border was FLAT, make it BLOCKED.
        2) If I am an L-case and my sheath border is NONE, pass the burden of blockage onto the walkway (using two parameters perhaps)

===============================================================================
