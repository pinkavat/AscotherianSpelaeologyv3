
    TODO REMOVE FROM GIT IF WE MAKE THE CODE PUBLIC


    BUG LIST
        1) Grid Transform autoparent adjust thingy is buggy; transforming, interpreting, transforming, then interpreting again yields bad results.
            adjusting params of gT triggering a re-inherit MIGHT fix problem; or might exacerbate. Needs thinking. As stands, works, but fragile.
        2) L-case still not handled

    FEATURE / IMPROVEMENT LIST
        1) Flip option for mapHelper autotile
        2) "waterworld" grid recursor kitbash
        3) Some sort of error handler (mostly to deal with malformed signatures (or we could sidestep them with a later "signature validity checker"))
        4) Same-same corner culling for sheathes
        5) Add "expansion direction" back in, for picking where to add lengthening parcels?

    WILD FUTURE OPTIMIZATION LIST
        1) Replace heap-resident parcel data struct pointer with data struct union (of all possible data structs, they're small)?
        2) Is recomputing the min dim data for the grid recursor actually cheaper than storing it?


    THOUGHTS ABOUT THE POSTPROCESSOR:
        1) See v1 and v2.
        2) Develop replacement automaton (a la KMP)
        3) Jan 8 idea: Just as UNRESOLVEDS can be filled with blockage as long as they don't obstruct, so too can BLOCKAGES be filled with blank floors as long as
            they still obstruct. The same logic can be used for BOTH CIRCUMSTANCES. Chew on that later.
        4) Jan 8 scrapped the edgetracer in favor of a void-appender device.
            NOTE: the global params should include whether this is permitted -- after all, the algorithm could be invoked to generate a small part of a larger cave
                    Think on't.
            An edgetracer of sorts may still be necessary for the doorways to work...?
            OR THE DOORS ARE PART OF THE ALGO, REALIZED AS E-PARCELS!!!

    ASSUMPTIONS TO ADD TO THE DOCS:
        1) Parcels always possess a tile on either side of their gate that doesn't contain the gate, to avoid the corner-clash sheath problem.
        2) All gates are present in the parcel (assumption from sheather). If a parcel doesn't use a gate it sets its size to zero.




    ASCOSPEL GENERATOR VERSION THREE
    This time for sure! ...*sigh*
    Launched December 2021 as a successor to ASCOSPEL VERSION TWO, which implemented the sheathing model but didn't go far enough down the resizing hole.

    THEORY:
        The new model is based on a simplified rect transform system, which considers the rotational centers and anchor points of each parcel to be their geometric centers,
        instead of their top-left corners.
        This is our thinking: the logic behind the gates, the grids, the sheathes, etc. can be as dirty and ugly as it needs to be, as long as it
            a) works
            b) has the simplest possible interface to the core-parcel designer and end map user, who care about
                1) Tiles
                2) Gates
                3) Level Metrics

    IMPLEMENTATION TODO LIST:
        1) New Ascospel Tiling Standard
        2) Half-precision Transformed Rects


    UNSOLVED PROBLEMS:
        Gate-gazumption. The new model considers gates to be tiles, not abstract offsets. This raises a) the spectre of gate size, which was handled in the kludges of v2's
        transform logic quite neatly, and b) an implementation difficulty with the new half-precision rect transforms.
        --> Here's a thought. The gates are by their nature rects as well. If we allow them to be centered too, they could be handled by the rect transform logic.
            HOWEVER, this leaves a bit of thinking up to the core-parcel designer; how do we overcome this?
        

    ON SHEATHES:
        Sheathes were initially a separate parcel so that we could take advantage of the modularized transform logic. Under the new model, the transforms
        are VASTLY STREAMLINED at a bit of computing expense (still cheaper than v1's ECP, no?) so if we assume EVERY PARCEL IS SHEATHED and EACH SHEATH belongs
        to the parcel it enshrouds, then:
            a) Sheathes can draw themselves in absolute space, and the transform logic will still correct their offset/rotation/mirroring
            b) The recursive structure and the grid positioner need not know about sheathes; the former only needs to transmit height/topoAdj/borderAdj and the latter
                needs only care about dimensions of the parcel overall (sheath included).
                WE ENCOUNTER A MINOR CONCEPTUAL HITCH WITH GATE-GAZUMPTION; the recursor and the grid need knowledge of GATES at least.
                --> This raises another reason we had sheathes as separate parcels to begin with: nonstandard base cores. Under the old system we could feed anything in.

===============================================================================
    DEC 27 (post-hedgehog realization)

    Our transform logic isn't as cut-and-dry as we would like. Therefore, it behooves us to abandon the double-precision stuff and run back to v2's transform system.
    We are a little wiser, however, as we have made the following observations:
        1) The rect transform system, if Modularized, enables a few neat tricks, such as making GATES rects of their own (which means we don't have to care about width
            adjustment / orientation, as the generator certainly doesn't). Hence, we should migrate the rect transform to its own file.
            (we still have the unsatisfying width/height dependency though)
        2) The Realizer knows not the Tree; the Tree knows not the Map; the Invoker knows only the Map; they communicate through the rect transform.
        3) The new tiling standard is better.
        4) Something's up with the border transforms (I think we forgot to do them at all in v2, though we didn't spot a problem, so maybe I can't find the code..?)
    
    Another observation about previous assumptions springs to mind even as I write, concerning sheath responsibility.
    In v2, Sheathes were added as parcels in their own right. This allowed us to take advantage of the modular structure of transforms, but induced a problem in the recursion.
    (recursors had to be checked for sheathhood, instead of handled uniformly). This sort of traversal must go.
        We've been tightening our assumptions yet further; Asco v3 is built on the premise that ALL RECURSORS ARE GRIDDED.
        Observation 1:
            Gate-gazumption is the responsibility of the grid controller.
        Observation 2:
            Sheathes, Landings, and Blockage-blobs only exist to connect one rect to another UNDER THE ASSUMPTIONS OF GATE-GAZUMPTION.
        Conclusion:
            Sheathes, Landings, and Blockage-blobs are the responsibility of the recursing parent, NOT the returned children.
        Confounding observation:
            The recursor must return a flexibility score as part of the resizing process. However, this score is not used in the final realization.
            Also, the resizing process assumes that all rects are flexible -- this implies that the landing strip, at least, is part of the child, not the parent,
            as resizing the landing strip is how an otherwise inflexible parcel resizes.
        SOMETHING WE FORGOT:
            There's a reason worldBorderAdj is in levelMetrics, and topo/heightAdj aren't. The latter are purely local -- decided onsite and not handed down anywhere.
            worldBorderAdj, however, is handed down and transformed.

    So, we need to establish what information is needed at which recursive pass.
        1) Initial decision step
            HANDED DOWN:
                1) Level metrics (including pre-transformed adjacency data [TODO worldBorder only (sheath not child resp.) or all (sheath child resp.)])
                    --> needed by recursors to decide their grid contents
            STORED AT SELF LEVEL:
                1) Grid placement of children (simplified untransformed coords)
                2) Children with rotation, etc. set but no translation coords yet
                    --> NOTE: because realization is in the abstract, child can be a reference to a type of parcel, rather than a generated parcel.
                        (i.e. the "data" pointer from v2 is conceptually meaningless THOUGH it does allow for a bit of modularity in prefabs...? Think over.)
                3) Per-row/Per-col flex scores
                4) Per-row/Per-col min sizes (as yet unaffecting sub-min-size children) (sent up as part of self's rect, which is what we store as children???)
            HANDED UP:
                1) Overall Flexibility score
                    --> Absorbed by parent's flex score grid calcs
                2) Overall Minimum size
                    --> Absorbed by parent's min size grid calcs
        2) Resizing descent
            HANDED DOWN:
                1) Target dimensional increase
                    --> Absorbed by flex distribution process using at-level flex data (invoker doesn't care about top-level overall flex)
                    --> At base level, absorbed by either abstract realizer or flex sheath
                2) Map pointer
        3) Realizing ascent
            HANDED UP:
                (Map is populated on ascent)
                1) Gates (gates are knowable only once the dimensions of abstract parcels are set, by distribution of the flexing)
                    --> Gates are processed by the parent if sheathing is the parent's responsibility (also gazumption MUST be the parent's responsibility)
                (Actual dim idea scrapped; realized rects are expected to conform to the target dimensions/translations given)


    Having written it out, we observe the following:

        1) The gates have to be handed up either way, but they don't necessarily have to be stored. (Tantamount to the same if we're handing back malloced structs)
            BUT if sheathing / gazumption is super responsibility, a parcel doesn't care about its gates at all.

        2) Gates are only knowable at realization time, and therefore aren't part of the initial recursion.
            THIS IS AN INTERESTING CONCEPTUAL PROBLEM WE HADN'T CONSIDERED. Clearly a prefab map section knows its own gates concretely (i.e. knows them at
            selection pass) but only parrots them out at realization.

        3) It doesn't really matter who handles the landing/shield if the transforms are modular. If the flex distributor observes that a given rect can't flex (or
            doesn't want to, perhaps?) then it can shift the burden onto the landing/shield as part of the sheath realization. This would allow us to keep landings
            out of the parcel model completely, where they have no right to be.
        CONCLUSION FROM THE ABOVE: THE PARCEL MODEL IS MORE ABSTRACT STILL THAN WE PREVIOUSLY SUPPOSED, AS SHEATHES ARE NOT AN INTRINSIC PART OF IT.
        FIND THE WAY TO REMOVE SHEATHING PROCESS COMPLETELY FROM THE RECURSIVE TRAVERSAL AND PLACE IT INTO BESPOKE GRID RECURSOR FUNCTIONS.
        IS IT ALSO INDEPENDENT OF THE GRID? (There may yet be interdependencies with gazumption and adj thinking)
        Also -- a nice advantage arising out of this is that sheath computations don't ever have to be rotated. We don't have to pass "adjusted" h-adj data down to a child,
        and the transforming of the realized sheath is done automatically by the realization process! (although border-adj does change)
            --> Hey, and if you want to talk modular, there's no reason (in v2) that the context had to be an ascoTileMap!
                (though maybe we might have to deal in wrapper functions to transform the tiles --> migrate over copy, single-change, and ninepatch (MS improved!) ops.)
        ALERT! THIS THINKING IS TOO OPTIMISTIC: SEE BELOW.

        4) Some abstract flexors have constraints on the sizes they can flex to. For instance, ice-slide puzzles (using the current generator) have to have 
            odd dimensions (? not actually sure if true but may as well be). If we can't guarantee perfect flexion for all parcel choices (and we certainly
            can't due to fixed prefabs) it may be wise to allow the realized parcel to return an "actual dimension" less than or equal to its distributed target; the
            difference can be made up by the landing/shield.
            ALERT! THIS THINKING CONDITIONS THE ABOVE. SEE BELOW.

        5) See point above about v2's data pointer. (ACTUALLY, AS SEEN BELOW, if we want grid modularity patterns we need that data pointer)
        
    One other thing: I was trawling the v2 notes and found a conceptual blurb about the L-adjacency issue. It seems that, in the absence of guarantees about minimum
    sizes of rects and gate placements, the concept of topological adjacency is meaningless (apart from a wild pipe dream about ledge postproc). All rects (from a 
    sheath POV) are nonadjacent, and adjacency is forced through by the gate-gazumper/sheathplacer. This may result in artificial-looking "blockage fences", but it's
    the better way to be sure of the L-adjacency bug without size guarantees, and it's simpler not to have to think about topo-adj as well.
    THIS MEANS, HOWEVER, THAT THE SHEATHING LOGIC IS UNDER CONSIDERATION AGAIN. TIME TO REVIEW THE OLD FILE AND MAKE SOME CHANGES...


    Implementation path as of Dec 27:
        1) Most abstract:
            DONE -- Rect transform 
                (notions of transform and dimensions; implies an integer grid)
                ("owned" by returned children, preset with minimal dimensions, mutated by parents for placement)
            PARCEL STRUCT DONE -- Recursive selector and realizer
                (selector is bespoke; metrics are bespoke too (no "abstract metrics"))
                (selector has the same signature as recursive generator, and above all the same returns)
                (realizer needs notion of FLEX SCORES, so recursive structure needs those)
                (realizer needs notion of MINIMUM DIMS; TARGET DIMS, etc.) (former is given by rect transform of the returned parcel)
                IMPORTANT POINT: The placement of flexed rects is based (in our model) on the flex grid. THIS REQUIRES A NOTION OF THE SHEATH, AS THE SHEATH SIZE IMPACTS
                PLACEMENT.
        {
        HOLD THE PHONE: WE'VE OVERLOOKED A MAJOR CONCEPTUAL PROBLEM.
            If we allow rects to "disobey" their commanded sizes, then placement depends on the actual size. Therefore, we can't allow rects to disobey, unless we want
            another level of recursion.

        SO: The landing strip and blockage shield are INTRINSIC parts of the flexible parcel, as they are the constructs that allow grow-arbitrarily parcels to fit a
            commanded size without disobedience.
            NO DISOBEDIENCE DURING REALIZATION.
        (found advantage: no need to transform walkways/shields)

        Related sub-observation: Where in the code does the landing/shield appear? It needs no preset data, as it is decided upon in-realization.
        Related sub-observation: landing always exists; this affects minimum dimensions. Review our minimum dimension assumptions.
        Related sub-observation: because the landing is now child responsibility, then Gate Zero doesn't mean squat (except perhaps to the walkway realizer)
            (Except also to the invoking context)
        }


        Solution to notion of sheath requirement above: The abstract realization function. It receives the self parcel, the context, and the target dimensions, and it
        produces a final parcel by mutating the context and returning gate rects.

        {
        MINOR OVERSIGHT: Gate rects are interpreted via the parcel's topological shape, which notion we have yet to decide.
                        Can such interpretation be left implicit, or is knowledge of the shape intrinsic to the recursion structure?
                        (it's a metric for sure...)
        }

        Therefore the grid realization function (which is a general function, presumably, provided with a data-pointer detailing the actual topology of the self for
        gazumption control and the grid dimensions for child handling) is just a specific case of a realization function.
        --> Advantage: this allows for potential later additions of non-grid recursors, though such would require a rewrite of generic sheathing logic etc.

            -- Therefore recursive process is defined as a realizer function signature, which takes the self parcelTree, a context, and target dimensions.
                Realization is effected by executing the root parcel's realizer function, which is trusted to execute child parcel functions.
                (Note: minor point; global params should be bundled with context perhaps, to save on transmission in other wise. Hard to refactor?)
                In the grid case, said function distributes the flexes among grid members, then uses the sizes thus computed to place sheathes and realize children.

        2) More concrete
            -- Sheathing logic (height/worldborder only)
            -- Flex distributor (separate or same with grid solver?)
            -- Grid solver
            -- Walkway/Shield realizer funcs (provide these with gate zero perhaps?)

        One last thing to consider before we launch into implementation: GENERATION PARAMETERS (make a more specific name like "parcelGenParams"?)
        These should be divvied up by the recursor. If we're doing patterned recursors (which we ought to do to save on repeating ourselves vis-a-vis grid logic)
        we need to work out how the "pattern" (whatever that is) expresses division of metrics. So far, v2's kludge has two forms: serial and parallel division, with
        the latter possessing a "shortcut" function to replace obligate locks with return locks.

        Also, where does the shape appear? In v2 it was in the pattern header (stupid). We'll put it in the parcelGenParam struct for now.
        WAIT: gazumption is easier if we remember the shape of each recursor (i.e. we don't have to make gazumption explicit for a recursor pattern, we just
        iterate over the grid) so the shapes are now intrinsic properties of the parcels.

End Dec 27: Parcel def and grid transforms done. The next steps:
    1) work out the actual flex dist comp scheme for grid
    2) write the grid recursor as an example of a generator function
        --> Prereq: grid representation scheme (two dims and a list of enums?)
    3) write a base-case generator/realizer pair (STORE GEN/REL STUFF IN THEIR OWN FILES IN A SEPARATE DIRECTORY??)
    4) The world-border adjacency affects the fundamental grid structure sheathing process, so we can't make the metrics abstract.
Final Thoughts:
    a) TILE_VOID is MS Tiling. Noted in file.
    b) Complex caves can be constructed directly using recursor grid notation; i.e. don't make it hopelessly arcane
    c) When do we think about the height decider?

Tomorrow: populate parcelGenerators subdirectory with some simple testable generator types 





===============================================================================
    Dec 28: Thinking about sheathes

    Solving the L-problem by declaring everything topo-unadj is an extremely bad solution. For one, it doesn't allow pruning to increase proximity. For another, it
    would leave huge strips of blockage strewn across the map.
    SUBOBSERVATION: We're going to have to port in protection flags from v1 if we want any sort of complex postprocessing.
                Though do note that we no longer have to worry about inaccessible floors -- they only arise as a result of blockage resolution and edgetracing, and are
                described (perhaps) by floor type (though it might be useful to flag the tile as inaccessible, just to make other post possible)
    So: We need to keep topo-adj BUT we don't need to keep it as a variable. Observe that in the v2 prototypes topoAdj was handed to one of an adjacent pair of subrects
        with non-connecting parcel shapes. IF we maintain an invariant as to which member of these pairs (say, the top left member, for instance) then topoadj derives
        directly from a) the shape and b) whether the parcel is on the grid's edge. Can we minimize this so we don't need to pass anything? Remember that sheathing is now
        handled by a fully bespoke handler.

    Stuff we can keep includes the height-adjacency fetcher from gridSolver in v2.
    Also note that "worldBorderAdj" means both topoAdj and heightAdj; worldBorderAdj isn't needed by the sheather, only by some sort of preprocess.

    Rebuilt the mapHelpers today; replaced clunky ninepatchrect with smooth autofiller, thanks to new standard

    Task for next session:  - get some prototype base case generators/realizers online
                            - get the generic base case online
                            - create walkway and shield handles with basic realizers for later fleshing
                                (create them using the same function, as it may behoove us to allow them to talk to each other)
                                (might also behoove us to hand them gate-zero, which is otherwise lost)





===============================================================================
    Dec 29: Some more observations

    1) Void shape handling transmits / requires some worldborderadj considerations.
        a) A recursor containing a void shape can only touch the world border (hence the selector only allows it if the worldborder touches it;
            THE SELECTOR MAY NEED TO BE ALLOWED DISCRETION OVER SETTING HFLIP AND VFLIP TO MINIMIZE SPECIAL CASES OF VOID INCURSION.
        b) A void-shape child transmits its worldedge to adjacent children.
        WAIT WAIT WAIT: MAJOR OVERSIGHT. IF VOIDSHAPES ARE ALLOWED IN RECURSION, THE IDEA OF A DISCRETE WORLD-BORDER-ADJ BREAKS DOWN; WE CAN'T HAVE HETEROGENEOUS
        STATS FOR A SINGLE EDGE. THEREFORE, IF WE ADD VOIDSHAPES TO THE RECURSION, THEY MUST BE PADDED ON ALL SIDES BY EITHER a) GUARANTEED WORLDEDGE (from the levelmetric)
        or b) OTHER CHILDREN IN THE SAME-PARENT GRID (so we can fill their worldborderadj fields directly)
        VOIDADJ INCURSIONS ARE A LATER REFINEMENT; LEAVE THEM OUT FOR NOW.

    2) Level metric division hits a bit of a snag vis-a-vis forks. Up to now we've been assuming an identical grid-handler for ALL recursors. Won't work with
        forks vs. nonforks; so we either have to a) wrap the recursor in a metric handler that changes based on forks/nonforks (attendant transmission problems)
        or b) add fork detection to the recursor; which would sense the presence of a fork and divide accordingly.
        FLANGES, TOO, NEED SPECIAL LOGIC; MAJOR PROBLEM; MUST BE SOLVED IF FURTHER PROGRESS IS TO BE MADE.
        And here's the solution: add a single integer to each grid square in the grid pattern. This denotes the GROUP of that square. The groups are referenced by a master
        descriptor in the pattern header, which lists how many there are and whether any are shortcuts or flanges (with a bitfield, etc.).
        All members of a single group have their metrics divided serially; each group gets a master metric derived from the source metric in parallel (with
        flange and shortcut modifications as necessary).

    3) The flex strategy is only partially known. We know that the flexibility of any row/column depends on its members. Is it the average or the minimum?
        We know the overall flex is determined by all the rows/columns. Is it the average or the maximum?

    Made no progress on previous session's "tasks for next session"
    Added task: Since we've come up with a new concept for the metric divider, prototype it independently. Much future architecture depends on at least having a 
    handle on the parameters, so we should definitely pump them into a standalone prototype.



===============================================================================

    OBSERVATIONS MADE AT THE BEACH OVER NEW YEARS:

    1) Previous world-border-adjacency considerations assumed nonconcave recursors; that is, if we have void incursions we're going to need to inform the 
        rects that share corners, as well as the sides; i.e. it shares the signature of height-adjacency, and therefore perhaps some of the logic

    2) Sometimes a base rect will have a "failure" exit and a "success" exit (think bike puzzles and the seafoam island ice puzzle). The recursor logic we're
        developing now can handle this, if these exits are understood to refer to the flange exits of shaped parcels. Change documentation later to reflect this.

    3) In the same vein, we need a better understanding of path TYPES (mere "challenge ratings" aren't enough). If we tell the generator, for instance, that a rect
        is part of a fail path or a backwards-edge loop, it can make more intelligent decisions than merely assigning arbitrary challenge to what's downstream of a ledge.

    4) Blockages adjoining the world border should fill with void, then correct for impossible configurations using a CA pass.


===============================================================================
    Jan 2: Back on the horse in the new year

    Wrote a skeleton for the genParameters; it occurs to me that the locking mechanism is bound about with reward mechanisms. After all, flange locks protect goof or
    encounter prefabs that are very, very worth it; we established in v2's thinking that they are almost certainly set at a higher-than-generator level, as opposed to
    permitting incidental goof to be so locked off. It behooves us therefore to link the lock to the reward somehow, so that we can finely tune at what point in the game
    backtracking becomes possible.
    Or not.
    If the goof is set at the highest level, the pattern is set also and contains obligate locks protecting the goof. The backtrack lock data is only for flanges that
    arise organically as part of the generation process, and protect moderate-level incidental goof.


===============================================================================
    Jan 3: CA Problemma

    Just had a disquieting thought about tile-level postprocessing. Right now we have a reasonable trans-parcel post step involving the resolution of blockage tiles,
    but all blank floor tiles are being treated as sacrosanct. This is not good. Post-factum processing should be given a notion of critical path tiles, as well as 
    protected tile regions, and then be told to go ham on the whole thing, so as to cover up the gridlike origins of the structure.
    The problem with this is that (general-case) unprotected floors exist only in the landing strips and, in the current incarnation, landing strips have no way of
    knowing what the path inside them looks like.
    Because of the nature of gates as a "residual", the gazumption step can't take place until a parcel is generated. This means that the parcel has, at present, no
    idea of where its gate zero is going to be moved to. 
    THIS CANNOT BE ALLOWED TO KILL THE PROJECT.
    Possible (slightly inelegant) solution: Make the walkway a RESIDUAL grid-transform.
    The parcel realizer is told what its target dimensions are and then
        a) adjusts its internal offsets and realizes its own tile data, then
        b) computes the size and shape of the walkway, then stores it in the residual data
        c) does the same with the blockage shield.
    When the invoking context takes the returned parcel, it
        a) gazumps the gates from adjacent parcels, storing the original gate-zeroes somewhere (NOTE: SEE BELOW: OLD GATES NEVER MUTATED)
        b) using the gazumped gate zeroes, the old gate zeroes, and the residual walkway, realizes the walkway (grid transform inheritance followed by general realizer).
    The walkway realizer receives two gates, the walkway rect, the blockage rect, and the map context. It then has enough information to write a protected path, but
    doesn't yet have to (for modular prototyping purposes).
    DECIDED ARBITRARILY THAT THE RESIDUALS ARE IN LOCAL SPACE.

    This idea places yet more burdens on the grid recursor. We're going to have to mete out some of its responsibilities to other files somehow.
    Also, if the walkway is a residual and the burden of resolving it is placed on the invoking context, responsibilities are clouded a bit vis-a-vis nongrid recursors.
    (but sod those; we have no intention to ever build any such).
    The current procedure for the grid ideator is roughly:
        1) Choose height offsets (height choice step), and compute sheath data and minimum sheath sizes and store in data struct (sheathing step)
        2) Based on the pattern, divide the metrics. (metric div step)
        3) Based on the pattern, generate children.
        4) Based on the pattern, rotate and mirror children.
        5) Compute and store per-row/per-col minimum dimensions in data struct
        6) Compute and store per-row/per-col flex scores in data struct
        7) Compute overall flex scores for whole parcel (unclear flex amalgam step)
    The current procedure for the grid realizer is roughly:
        1) divide target dimensional increases among rows and columns of grid (flex div step)
        SEE BELOW; PROBLEM WITH INHERITANCE AND THE GRID TRANSFORM
        2) realize child parcels
        3) TRANSFORM CHILD GATES AND RESIDUAL WALKWAY/BLOCKAGES BY CHILD'S GRID TRANSFORM TO BRING THEM INTO ABSOLUTE SPACE
        4) perform gate-gazumption
        5) realize sheathes and child walkway/blockages (sheathing step)

    Random other thought: we could store protection flags by abusing the tiling field of the nontiling TILE_BLANK, though that seems a bit risky.

    For God's sake start work on this.


===============================================================================
    Jan 4: Grid recursion skeleton

    Brief observation: Bridges are nongrid recursors, due to their unusual height requirements.

    Now for a start on the grid recursor skeleton.
    We don't need to worry about sheathing logic for now; all we need is to make sure that
        a) We know where to hook in sheath dimensions into the min-dimensions/resizing code
        b) We know where to store sheath data in the parcel data struct
    See yesterday's notes for the outline.
    File should be its own header/c pair, linked into the rest via parcelGenerators.h
    Dependencies:
        - generation parameters             (genParameters.h)
        - parcels                           (parcel.h) (by extension gridTransform.h)
        - map helpers (for the sheathing)   (mapHelpers.h)
    Assistor files:
        - sheathing logic (to decide)
        - walkway/shield realizer           (depends on parcel.h)
    
    So the first step is to create the walkway/shield realizer function.
        Dependencies: parcel.h, mapHelpers.h
    Takes a pointer to a parcel and a gridTransform of the gazumped gate zero.
    AT NO POINT IS THE PARCEL'S GATE ZERO MUTATED.

    A THOUGHT WHICH DESERVES THOUGHT:
        SHOULD WE BUNDLE LEVEL METRICS WITH THE PARCEL STRUCT?
        If we do, we 
            a) eliminate fairly redundant dependencies
            b) eliminate a redundant parameter through the recursive structure
            c) allow post-processing to remember which metrics generated the parcel
                (which, for instance, allows the walkway/blockage realizer to access the global state and local locks and thereby make
                 decisions about its content)
    Good idea. DO SO. DONE.


    MAJOR MAJOR OVERSIGHT: THE PARCEL RESIZING AFFECTS ITS GRID TRANSFORM.
    BE EXPLICIT:
    IF WE ARE TO KEEP THE CURRENT SCHEME, THE FOLLOWING OCCURS:
        1) THE INVOKER GETS TARGET DIMENSIONS IN ITS OWN SPACE.
        2) THE INVOKER THEN HAS TO CLOBBER THE DIMENSIONS OF THE CHILD PARCEL TO MAKE THE INHERITANCE WORK.
        3) INHERITANCE TAKES PLACE; MIN DIM DATA IS LOST!

    THEREFORE: WE KEEP MIN DIM DATA ELSEWHERE.
    DONE.

    We might later need a gate index translator to correct for parcel transforms (in the grid recursor).
    Here's v2's code, may need a bit of editing:
        // 1) Rotate
        int newGateIndex = ((int)gateIndex - (int)(parcel->rotation));
        if(newGateIndex < 0) newGateIndex += 4;

        // 2) Flip
        if(parcel->flipH) newGateIndex = (newGateIndex == 1) ? 3 : (newGateIndex == 3) ? 1 : newGateIndex; 
        if(parcel->flipV) newGateIndex = (newGateIndex == 0) ? 2 : (newGateIndex == 2) ? 0 : newGateIndex;

    Wrote what seems to be a successful hook for the walkway and blockage realizer in mapHelpers.c; really ought to be elsewhere but hey.

    Next up is the grid signature.
    Signature needs:
        0) Number of parameter classes
        1) Parameter class shortcut identifiers (list of booleans or bitfield?)
        OR NOT THIS AT ALL; MERELY INT MATCHING. Negative Ints are "shortcut" paths.
        Hm; though we have multiple such; like flange ids. May need something else, like a list of enums denoting class type
        as well as a list of ints denoting how many rects are in each class (or we could just count that for a performance hit?)
        WHAT'S EASIEST FOR THE PATTERN AUTHOR??????

        2) Grid dimensions
        3) Grid List of shapes
        4) Grid List of ideator functions (or the selector)
        5) Grid List of Parameter class IDs
        6) Grid List of rotations and flips (positioning implicit in traversal)
    This is shaping up to be its own header file; after all, instructions to the generator are presumably transmitted as arbitrarily complex
    grid signatures, no?

    Wrote skeletons for signatures and the grid recursor.

    Had a midnight thought about a very inefficient "smart brush" tool for autotiles.
    Makes a mask -- any tiles of the type placed during the brush pass are marked on the mask and autotile with other tiles so marked.

    Next up: code outlines for the recursor itself, and at least one test case

===============================================================================
    Jan 5: The grid recursor (sans sheathes)

    Basic stuff so far all seems good; the next step to attempt is moving/outsourcing flex division (even into a static func in the gridfile is better)
    The gist is this: a representation of row/column dimensions, which the function takes in and modifies based on row/column flex scores.
    Amalgamating the flex scores is harder (need-to-know parcel array, etc.)
    What representation for row/column notation?

    Finished the ideator today.

    Had an interesting thought for a FUTURE CHANGE: "waterworlds". There's no reason why the grid recursor logic can't be kitbashed into something
    capable of stringing multiple water bodies together, with waterfalls as staircases. We originally thought that it was impossible, but we were thinking
    about it from the wrong direction -- lake expansion isn't a post-process, it's baked into the recursive structure.
    Such an approach -- paired with void-incursion -- could lead to very fiddly geometry indeed even without postprocessing.
        


===============================================================================
    Jan 6: The grid realizer (sans sheathes)

    Found something we hadn't considered vis minimum size. See "Bug list" up top; it's the one to do with minimum size of the base case.
    The base case can't be implicitly inclusive of its walkway; it has to be explicitly inclusive.

    SOLVED; however we've noted that SHIELDS ARE OPTIONAL; the MINIMUM SIZE MUST NEVER INCLUDE THEM. Remember that topological blocking is handled by sheathes,
    NOT shields. Shields are just padding. If a generator can fill its parcel without using a shield, all the better.

    The grid realizer is up and running, and, bar some weird hiding bugs, seems to work fine.
    Next step, I suppose, is getting some actual topology into this thing and getting the sheathes/gates/gate-gazumption online.

    So: we need to think about:
        a) Gates. They are represented by rect transforms, but what guarantees are made about them that we can count on?
            --> In parcel.h, we've chosen this: gates are always one tile thick and lie on the edge of the parcel, inside it.
            Also, we need to port over v2's gate index transformer; we can't avoid it. Fortunately we're free from the burden of inversion/offset change, etc.
    
    Thoughts about gates:
        1) Note that even though the generators care about a uniform minimum gate size, the actual gazumption process can't.
            Reason being that RS-stairs are gates of alternative width. The gazumper must operate at any size (within reason; for instance, we can guarantee that
            if we project a gate onto its owner, it will fall within the owner's bounds in that dimension)
        2) The gazumption process works as follows:
            The grid recursor iterates over every child parcel.
                gTInherit all the child's gates, bringing them into parentspace.
                    (do we check for shape or just blindly run gTInherit on all gates? Checking might save us a deal of work)
                If the parcel is (of type V or) of rotation 0 and on the left edge of the grid, sheathe it and move on (no other parcel is imposing its will)
                (otherwise)
                Find the parcel facing this parcel's gate zero (index translation to get the direction, then a bounds check perhaps (though this would only
                come into play in malformed parcels, no?)
                Find the gate facing this parcel in the other parcel (index translation of the other parcel)
                Hand both these gates to the walkway realizer.
                Hand the second parcel's gate to the sheather as the first parcel's gate zero (this can be where the sheather is invoked; be sure also to invoke
                it if the parcel doesn't inherit (is on the edge or is type V))
        3) The gazumption process implies a bit about the structure of the sheather:
            It takes some description of the sheath, plus up to three gates, and renders into the map. Ideally we'd want to hide parcel from it, and put it in a
            separate file.

    Deleted X-shapes today.

    SO. SHEATHES. TIME TO RETHINK THE DREADED LOGIC AND PORT THE SHEATHES OVER ONCE AND FOR ALL.
        Sheathes are their own thing, depending on the following:
            1) Height adjacency, custom-computed by their invoker
            2) World-border-adjacency, either derived from genParams or custom-computed.
            3) Grid Transforms: no matter how they react to their children, sheathes exist in parent-space.
                NOTE: this could just mean that they reuse their parent's transform
            4) Topo-adjacency ???
    PERHAPS IT'S TIME FOR A NEW IDEA. After all, if the grid recursor controls the sheathes, it can control all of them at once. Not sure what the implications of this are.
    Probably nothing useful.
    Why did we abandon the idea of sheathes as separate parcels in the first place?
    It's not quite clear.
    HEY: Don't abandon the idea of sheathes being parcels themselves just because rewriting would hew too closely to v2.
    The only conceptual muddiness I can see is gate-gazumption and its implications for walkway cell-level writing.
    Also, sheathes aren't really parcels, conceptually. They merely look like them.
    After all, a sheath:
        1) Can only ever have one child
        2) Isn't returned by the parcel selector
        3) Depends for its realization on data that is a level above in the recursion
        4) Doesn't flex meaningfully; DOESN'T PROVIDE WALKWAYS OR SHIELDS

    So. Sheathes are not part of the parcel tree. Instead, they are grid transforms, fed data from a pool held by their invoker (in our case, only a grid recursor)
    Operations involving sheathes:
        1) Computation of sheath data           (adjacencies, shape?)
        2) Fetching of dimensional burdens      (nothing)
        3) Fetching of core offset              (nothing)
        4) Realization                          (map context, transform must inherit from grid parent, gates!!!)


    HOLD ON. MAYBE HAVING SHEATHES AS THEIR OWN PARCELS IS A GREAT IDEA.
    After all, this way the landing strip/blockage is AUTOMATICALLY HANDLED which is one heck of a boon.
    --> not only automatically handled, but actually shunted into its own parcel, which gives us total modularity and makes the gate-gazumption even simpler
    --> although there's no such thing as "walkway ideation..."
    Only conceptual hurdle: the realization resizing step.
    In the existing model, we know how to place parcels in the grid because they are guaranteed to be their expected size.
    All along we thought that meant that if the parcel was the wrong size, it could correct by adjusting its walkways itself. But how could a parcel know if it
    can't be the required size except by realizing itself? All we need to eliminate this flaw is the following: a sheath that knows what size constraints its
    core-child is under.
    What constraints could those be?
        --> Fixed size: core is fixed in size
        --> Totally variable size: core can be any size
        --> Incrementally variable size: core's size varies in known increments (i.e. core ends up being even-dimensioned, say)
    ~~~although, we could have the SAME EFFECT FROM A HELPER FUNCTION SET THAT IS ACCESSED BY THE PARCEL GENERATORS.
        This is better; it means we can keep sheathes as their own weird thing.
    So, no sheathes as their own parcels.


    PROBLEM: GATE TRANSFER BETWEEN PARCELS ISN'T AS CUT-AND-DRY AS IT SEEMS...
    We can get both gates in parentSpace but NOT in walkwaySpace, where they need to be.
    Hmm. Our only option, it seems, is a REVERSE INHERIT: place the gate in the walkway's coordinate space.
    This is a terrible, terrible idea.
    May be easier to run back to the gate representation from v2...
    So: here's the use case: We have a "gate" in one grid transform, along one of its edges. It shares this edge with another grid transform, which is the same size
    along that edge always. Ergo we can flipflop between the two however we like.
    MAJOR HELPFUL OBSERVATION:
        THE SHIELD AND THE WALKWAY ARE NOT TWO GRID TRANSFORMS IN THEIR OWN RIGHT; THE'YRE MERELY TWO NUMBERS (incursions!) IN THEIR OWNER PARCEL SPACE, HANDLED BY
        A SEPARATE FUNCTION.
    THUS ALL WE NEED TO DO IS GET THE GATES IN PARCELSPACE.
    REWRITE THE WALKWAY CREATOR AS A SEPARATE FILE THAT RUNS ON PARCELS.
    Done. Walkways/shields are now no longer gridTransforms.
    It's getting more and more like we barely had to do anything to v2...........
    Ah well. Don't let that stop you.   
 
    GO BACK TO v2; REWORK THE LOGIC FOR LEFTSIDE ZERO; REINTRODUCE DEGREE-FOUR GATES(?)
    Did so. Gates now fully functional (fingers crossed)

    ONE LAST THOUGHT: Don't forget to correct for the gazumpee's flips during gate-gazumption (may need to invert the gate received from the gazumper)
    
                    
===============================================================================
    Jan 8: Gazumption & co; REMOVING THE EDGETRACER ALGORITHM

    Foresaw a problem which we may have overlooked:
    The reason sheathes were their own parcels was that we could allow CORRECTION OF THE CHILD'S GATES BASED ON THE SHEATH'S CULLED EDGES.
    THIS IS IMPORTANT: THE CHILD RETURNS GATES AS IF IT IS UNSHEATHED, but the sheath CHANGES THE SIZE, and, if we allow SHEATH PRUNING, not by constant proportion.
    I believe (though I haven't verified formally) that under v2's assumptions about the nature of sheathing, even if we allow pruning all the members of a grid
    are guaranteed to fit exactly in their rows and columns. Let's assume that part of the sheath data handled by the grid is a "core offset" (that's either 0 or 1
    in each dimension). This doesn't really help us vis-a-vis rotated/mirrored child gates on the underside, however.
    So instead of a core offset, we look at the sheath-data's culling decisions themselves.
    NOTE THAT SUCH A CORRECTION WILL TAKE PLACE MULTIPLE TIMES PER GATE:
        1) Gazumption
        2) Sheath realization
        3) Parent gatesetting
    There are two transforms at play: transforming the gazumper's gate into grid-cell-space, based on the gazumper's sheath, and transforming that back into gazumpee's
    space, based on the gazumpee's sheath.

    HOLD THE PHONE: If we observe, as above, that the sheath culling between adjacent cells is the same, that must mean that their gate cores align, always. If it were
    otherwise, we'd have an abruptly terminated sheath.
    HOLD THAT HOLD: We're no longer certain of that assertion.

    It's time to simplify our assumptions, to make the algorithm comprehensible and not induce preoptimization paralysis. If nothing else comes of this work,
    we learn that lesson.
    THERE ARE ONLY TWO CIRCUMSTANCES in v2's sheathing in which a sheath's edge is made of blank floor.
        1) The rects are topologically adjacent and height adjacent
        2) The rects are height adjacent and not topologically adjacent, but the neighbor is footing the blockage burden.
    In the former case, the floor can be costlessly blank (and the gate realizer can draw critical-path floor instead of stairs)
    In the latter case, a two-wide blockage is no worse than a one-wide blockage.
    WE DEVELOPED THE SHEATH CULLER TO MITIGATE SPACE LOSS. The flex algorithm, however, gives us more space sense than ever before. We can splurge on sheathes.
    Here's the snag: the sheathing model is built on the assumption of world-border culling; indeed, world-border is the only remaining case in which a cull
    *must* occur for the whole thing to work. If there were no void incursions, then it's not a problem: the alignment is guaranteed.
    Since there are void-incursions, however, we must think a little harder about our assumptions before beginning the sheathing/gazumption process.
    It *would* be nice to obviate the need for sheathing data completely, though; if we recalc it at realization time (knowing the dimensions ahead of time because
    they're constant). Hm.
    WE HAVEN'T ACTUALLY THOUGHT ABOUT WHETHER THE EDGETRACER DOES ANYTHING AT ALL. Somewhere, buried under a mountain of paper, I thought I had such a proof.
    Turns out no -- it's a badly formulated hunch. ABANDON THE EDGETRACER. THINK INSTEAD ABOUT VOID-INCURSION; the theory is this: the incursions will be (in the
    absence of a tracer) locked off behind walls, which will have to be punched through by a system. That's easy enough to do in post -- just look for unconnected
    voids, get their dimensions (they're guaranteed to be rects, and we could even abuse the variant system to make it easy on the post-processor)
    Then: scan out from their edges. If all you encounter is wall, and the walls tot up to less than the dimension of the incursion, we can intrude.
    How do we handle nested incursions??
    THUS: Void is at height zero. Thus, if the two times the void-parcel's height is greater than its least dimension, the parcel cannot possibly connect to the
          outside-the-map-void AND FILLS ITSELF WITH INACCESSIBLE FLOOR TILES AT REALIZATION TIME.
        Otherwise it remains void, and is handled by the post-processor accordingly, because the processor knows that at least one of its edge tiles (or just none, if
        even) will touch the void-edge of the map.
    
    All right. We've convinced ourselves. The edgetracer goes, in favor of void-regions marking themselves and taking care of themselves.
    Implications:
        1) All sheathes are now guaranteed to add the same amount of space; therefore sheath-data storage in the recursor's data struct goes.
        2) As a direct result, all child cores are guaranteed to align gatewise; thus, no gate transforms are needed.
        3) World-border adjacency now NO LONGER NEEDS TO EXIST OR BE TRANSMITTED. Thus we remove it from parameters. 
            Height-adjacency is the only thing to consider, and this is drawn from the grid unit at realization-time.

    Here's the gazumption algorithm again:
    For every grid child parcel:
        1) The gazumpee's gate in question is gate zero; if the parcel is V_SHAPE or faces an edge, handle in some other way*
        2) If the gazumpee faces up, gazumper's target gate is 1, etc. (gazumperGate = 3 - (gazumpeeGate + 2)%4)
        3) If the gazumpee is flipped (H if 1 or 3, V if 0 or 2), then the gazumper's gate inverts.
        4) Take the two resulting gates and feed them to the gazumpee's walkway realizer.
        5) Clobber the gazumpee's gate zero with the gazumper's gate. Now ready for sheathing pass (which could, in theory, be lumped here also)

    * Unsolved problem in grid-gate-gazumption and walkway-realization for the entry-facing gates
        Also concerns forks, where many children adjoin one master entryway...?

    DARNBLAST IT ALL
    Even a simple test of fixed-size sheathes is sufficient to show that such wastes FAR TOO MUCH SPACE. We'd overlooked a single case:
    When a child abuts the edge of its parent, and is of the same height, then topo-adj is handled by the parent's parent.
    Thus we have a blank void of nothingess that can only translate into blockage.
    It's time to rebuild the sheathing logic, with pruning completely realized in it; and it's also time to build the transform system.
    We can still scrap the worldborder stuff though. That's not nothing!
    Topoadj is back (but it's still inferred)
    
    Detected a minor problem in the variable-sheath assumptions, and, therefore, a new assumption is created (see #1 at top)

    So: we're back to needing
        a) a way to describe the parcel core's position within its sheath
        b) which is needed by a gate-corrector that brings gates out of/into grid-space.
    The sheath data computation results in Edge and Corner types in v2. Can we improve on this in any easy way?

    Sheathes can be their own parcels, handling walkways and blockages themselves, if we refactor in the following functionality:
    THAT THE PARCEL REALIZATION STEP IS TWOFOLD: FIRST, THE PARCEL REPORTS ITS DIMENSIONS; THEN, IT IS REALIZED.
    This breaks the pure recursive structure and the overall flex assumptions.
    NO. COMMIT TO THE EXISTING FORM.

    Sheath skeleton online.
    Base case now has legitimate-looking gates.

    Next up: the transformer from in-sheath gate coords to out-of-sheath gate coords and back again

    Basic sheathless gate-gazumper now online. It's a nightmare incarnate, but it works (hopefully)
    Just need to
        a) Get it sheath-sensitive (COMPUTE SINGLE DIMENSIONAL OFFSET OF CORES, THEN JUST ADD SAID OFFSET TO THE GATE WHEN IT'S IN CELL-SPACE...? 
        b) Add entry gates (....? Conceptual thoughts)

    Finished off the evening by (re-)adding cliffs and water to the cairo renderer.
    Discovered thereby a hilarious bug involving multiple copies of the tilemap; switched it to a non-header approach to solve.
    Also left TILING LARGE In unsolved state. Sort out.

===============================================================================
    Jan 9: Sheath realization

    Started off at 5PM by doing the gazumption sheath-compensator (simpler than I thought; hope it does in fact work..!)
    Finished at 10PM by writing the sheath-realizer. Christ, what a job. Now that's a segment in need of serious optimization.
    The frustrating thing is that you just know that an oldschool dev could get high on shrooms and code seven lines of magic-number-riddled
    assembly to do what you just barely managed to do in 144 lines of C.


===============================================================================
    Jan 10: Sheath computation

    Successfully lifted v2's sheathing logic (minus the same-same corner culling, which is a future optimization).
    Hooked it up to topo-adj (through a neat kitbash of the gate-transform logic) and height-adj successfully.

    Next up: Recursor gates and landing strips. This requires a little conceptual thought.
        Problem 1: Which recursor(s) are the exit(s) of a rect? Is this signature data or computed?
        Problem 2: Forks need a little extra logic, because they possess 
            a) A nonstandard walkway
            b) An EXIT STRIP, which can be in one of two places
    Right now, rects abutting the edge don't get gazumped -- their walkways reflect their own gate-zero. 
    This is fine.
    
    BEFORE WE CAN REASON ABOUT WALKWAYS, we need to know some global parameters, like PATH WIDTH and GATE WIDTH.
    Are these parameters truly global? NO; they just have to be consistent.
    (we'd want the main path to be 2x wide, while the flanges need only be 1x wide)
    We can hammer these into the struct temporarily BUT
    It's time we got the parameter divisor online -- we have it mostly worked out conceptually.
    So: it's time to flesh out the parameter theory, as it relates to division.
    In v2, we had two variants: CRITICAL and SHORTCUT paths, and three sets of locks.
    Critical paths enforced the mandatory locks, and could enforce the optional locks.
    Shortcuts enforced the backtracking locks, but it's not clear whether they also have to enforce mandatory locks, which was an unseen flaw.

    In our new case, "paths" can be grouped into the following kinds:
        1) CRITICAL:    The mandatory path walked to traverse the cave from entrance to exit.
                            Any rewards on the critical path are incidental goof.
        2) SHORTCUT:    A path that connects the critical path to itself, but using lock privileges not present on the critical path.
                            Rewards may become present as shortcuts appear; this is reward-adding.
        3) FLANGE:      A path not on the critical one. Responsibilities here are not clear; if there's a branch in the level topology
                            (say, a secondary exit to the cave) then the path leading thither is also critical.
                            Flanges could also arise naturally, as part of recursion on I- or L- parcels; this would result in E-parcels
                            appearing bearing goof (reward-adding again).
                            So what locks a flange?
                    --> Actual parcels are divided therefore into Obligate flanges (which are the T- or X- parcels leading to another critpath) and 
                        Incidental flanges (generated out of nothing).
        4) LOOPBACK:    Ledges connecting paths back to themselves need better typing than before; such ledges could be goof-draws (reward adding again!)

    By the by, where would we stick "waterworld" in this? "waterworld" needs to talk to the height-adajcency system, zeroing it out.
    Here's a thought: If the initial condition to the generator is JUST A GRID SIGNATURE, then INTERNAL grid signatures match the initial condition, and this
        affects how we consider metrics.
    Is this the case?
    Time for research. In our observation of source material, we see that a parcel can be told to contain (apart from "make it up yourself"):
        1) Ladders/Holes/Exits (plausibly individually-functioned)
        2) NPC encounter prefabs (either en passant or terminal)
        3) Good quality Goof (usually terminal, though some is en passant -- needs good signifiers though)
        4) Signature feature (think Rock Tunnel's RS-ladder thing or Iron Island's elevators)
    #2 and #3 contain references to data beyond the scope of the generation process. If the generator is to handle these as part of its grid signature, it needs
    to be able to tell the invoking context, at the end, just what it has created and where, to allow links to the entity/goof table.
    Note: #4 is not mentioned, because #4 would be written with parcel logic, only merely not selected.
    Some more complex NPC encounters would also be written with parcel logic, to allow for interesting geometry.
    Here's the thing... even AUTOGENOUS NPC encounters need reference to the NPC population system, and we'd be foolish not to do the same with goof.
    Say, for the sake of argument, that a cave pregenerates its NPC encounters in a table, and its goof likewise.
    The upshot of that is this: The parcel solver is now having to distribute a table of things, which is essentially a more general case of locks,
    AND SHOULD REPLACE THEM COMPLETELY (...?)

    So: we have a new conceptual data type, the "Thing which appears in the caves"
        This type includes NPC encounters, locks, and goof.
        The selector checks these, and activates associated parcel generators, passing extra data from these items into the extra param fields of said generators.
        Serious NPC/goof prefabs can be implemented by deploying a parcel to whose metrics these data have been added alone.
        WHICH RAISES A POINT ABOUT METRIC DIVISION: We don't start with a metric and a pattern, we start with a metric and a pattern for whom metrics may already
        have been set.
        So how to we get this data into the system in the first place? It'll have to be by adding data to the signature (which is a waste, no?) UNLESS
        this is how we get goof to arise automatically: by adding it to the list handed down to the next recursor. Think on't.
        Or, perhaps, we add a param to the recursor, a param left null by most invocations. If non-null, it points to WAIT THAT's just the signature idea again.
        So: the signature now includes an optional array of lists, where each list is a set of things that is copied into the metrics given to the appropriate
            recursive subparcel as part of parameter division. (Pointer to stack-resident arrays managed by invoker)
        If we want locks, we add them to the desired parcel as listed items.
        What if we want to merely *allow* locks to be used by the system...? I rather liked the elegance of the previous version -- it mixed permissions and
        gameplay topology neatly.
        OH: we're being daft. We have two lists; one is for "Must" and one is for "Can".
                --> Divide into "Can-critical" and "Can-shortcut"?
        How does this jive with flanges/shortcuts?
    Hey Hey HEY! This idea helps with our "challenge / reward" problem! We can give the table elements challenge/reward ratings.

    Hang on. Have we just worked out another level to the AscoSpel algorithm?
    What if EVERYTHING in the cave were so described, with nothing left to chance?
    E.g. we'd say "make this an I-shaped parcel containing a bike puzzle and two NPC encounters, with more bike puzzles if you wish" and the generator would just
    go ham on the whole thing --> that is, it would use up its CHALLENGE RATING on the things we said we needed, and use up its REWARD RATING likewise, and then
    SPEND THE REST on what we say it CAN have.
    Maybe "can-haves" need better notation than list? (can't really see why on a modern machine)
    REMEMBER! v1 was 3x as large as you are now, with fewer features!
    HEY! THIS IDEA SOLVES THE PROBLEMS OF:
        - Global allowances
        - Cave biome themeing
        - Signature mechanic system

    NOTE: "spending" the challenge rating on things just in my own parcel means that the level metrics are parcel-specific in the initial condition.
    So, for the first step, the recursor would start by copying stuff over..... Hm.
    We can't ditch the first recursor pass, because it sets up the grid for us.

    WE CAN PROTOTYPE THIS SYSTEM INDEPENDENTLY OF THE REST OF THE STRUCTURE: the coordination between item type and parcel generator is handled by the selector.
    The question is: what does it mean to be a "shortcut"?


===============================================================================
